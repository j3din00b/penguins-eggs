/**
 * penguins-eggs - Kernel management utilities
 * Unified vmlinuz & initramfs detection for multiple distributions
 */

import fs from 'node:fs'
import path from 'node:path'
import os from 'node:os'
import { execSync } from 'node:child_process'
import Distro from '../distro.js'
import Diversions from '../diversions.js'
import Utils from '../utils.js'

export default class Kernel {

    /**
     * Get path to vmlinuz
     */
    static vmlinuz(kernel = ''): string {
        if (!kernel) {
            if (!Utils.isContainer()) {
                return this.vmlinuxFromCmdline()
            } else {
                return this.vmLinuxFromFiles()
            }
        }
        return this.getSpecificKernelPath(kernel, new Distro())
    }

    /**
     * Get path to initramfs/initrd
     */
    static initramfs(kernel = ''): string {
        const distro = new Distro()

        if (!kernel) {
            kernel = !Utils.isContainer()
                ? execSync('uname -r').toString().trim()
                : this.getLatestKernelVersion()
        }

        if (distro.familyId === "archlinux") {
            return this.getArchInitramfs(kernel, distro)
        }
        if (distro.familyId === "alpine") {
            return this.assertExists('/boot/initramfs-lts')
        }

        // Generic patterns
        const patterns = [
            `/boot/initrd.img-${kernel}`,
            `/boot/initramfs-${kernel}.img`,
            `/boot/initrd-${kernel}`,
            `/boot/initramfs-${kernel}`
        ]
        for (const p of patterns) {
            if (fs.existsSync(p)) return p
        }

        this.listAvailableInitramfs()
        throw new Error(`initramfs for kernel ${kernel} not found`)
    }

    // -------- PRIVATE --------

    private static vmlinuxFromCmdline(): string {
        const kernelVersion = execSync('uname -r').toString().trim()
        let vmlinuz = `/boot/vmlinuz-${kernelVersion}`
        if (fs.existsSync(vmlinuz)) return vmlinuz

        const cmdline = fs.readFileSync('/proc/cmdline', 'utf8').split(/\s+/)
        for (const cmd of cmdline) {
            if (cmd.includes('BOOT_IMAGE')) {
                vmlinuz = cmd.split('=')[1] || ''
                if (vmlinuz.includes(')')) {
                    vmlinuz = vmlinuz.substring(vmlinuz.indexOf(')') + 1)
                }
                if (fs.existsSync(`/boot/${vmlinuz}`)) {
                    vmlinuz = `/boot/${vmlinuz}`
                }
            }
        }

        // Fix Btrfs subvolumes
        if (vmlinuz.includes('@')) {
            const subvolumeEnd = vmlinuz.indexOf('/', vmlinuz.indexOf('@'))
            vmlinuz = vmlinuz.substring(subvolumeEnd)
        }

        // Se esiste /vmlinux e /boot/vmlinuz
        if (path.dirname(vmlinuz) === '/' && fs.existsSync(`/boot${vmlinuz}`)) {
            vmlinuz = `/boot${vmlinuz}`
        }

        return this.assertExists(vmlinuz)
    }

    private static vmLinuxFromFiles(): string {
        const distro = new Distro()
        const kernel = this.getLatestKernelVersion()
        return this.getSpecificKernelPath(kernel, distro)
    }

    private static getSpecificKernelPath(kernel: string, distro: Distro): string {
        if (distro.familyId === "archlinux") {
            return this.getArchLinuxKernelPath(kernel, distro)
        }
        if (distro.familyId === "alpine") {
            return this.assertExists('/boot/vmlinuz-lts')
        }
        return this.assertExists(`/boot/vmlinuz-${kernel}`)
    }

    private static getKernelModulesPath(): string {
        for (const p of ['/usr/lib/modules', '/lib/modules']) {
            if (fs.existsSync(p)) return p
        }
        throw new Error('No kernel modules directory found')
    }

    private static getAvailableKernels(): string[] {
        const modulesPath = this.getKernelModulesPath()
        return fs.readdirSync(modulesPath)
            .sort(this.versionSort)
    }

    private static getLatestKernelVersion(): string {
        const kernels = this.getAvailableKernels()
        if (!kernels.length) throw new Error('No kernels found')
        return kernels[kernels.length - 1]
    }

    private static versionSort(a: string, b: string): number {
        const pa = a.split('.').map(Number)
        const pb = b.split('.').map(Number)
        for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
            const diff = (pa[i] || 0) - (pb[i] || 0)
            if (diff !== 0) return diff
        }
        return 0
    }

    private static getArchLinuxKernelPath(kernel: string, distro: Distro): string {
        if (Diversions.isManjaroBased(distro.distroId)) {
            const [major, minor] = kernel.split('.')
            return this.assertExists(`/boot/vmlinuz-${major}.${minor}-x86_64`)
        }
        const candidates = [
            '/boot/vmlinuz-linux',
            '/boot/vmlinuz-linux-lts',
            '/boot/vmlinuz-linux-rt',
            '/boot/vmlinuz-linux-zen',
            '/boot/vmlinuz-linux-hardened'
        ]
        for (const c of candidates) {
            if (fs.existsSync(c)) return c
        }
        return this.assertExists(`/boot/vmlinuz-${kernel}`)
    }

    private static getArchInitramfs(kernel: string, distro: Distro): string {
        if (Diversions.isManjaroBased(distro.distroId)) {
            const [major, minor] = kernel.split('.')
            return this.assertExists(`/boot/initramfs-${major}.${minor}-x86_64.img`)
        }
        const candidates = [
            '/boot/initramfs-linux.img',
            '/boot/initramfs-linux-lts.img',
            '/boot/initramfs-linux-rt.img',
            '/boot/initramfs-linux-zen.img',
            '/boot/initramfs-linux-hardened.img'
        ]
        for (const c of candidates) {
            if (fs.existsSync(c)) return c
        }
        return this.assertExists(`/boot/initramfs-${kernel}.img`)
    }

    private static assertExists(p: string): string {
        if (!fs.existsSync(p)) throw new Error(`File not found: ${p}`)
        return p
    }

    private static listAvailableInitramfs(): void {
        try {
            const bootFiles = fs.readdirSync('/boot')
                .filter(f => f.startsWith('initrd') || f.startsWith('initramfs'))
                .sort()
            console.error('Available initramfs in /boot:')
            bootFiles.forEach(f => console.error(`  - ${f}`))
        } catch {
            console.error('Cannot read /boot')
        }
    }
}
